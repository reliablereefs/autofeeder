#![allow(dead_code)]

use anyhow::{bail, Result};
use core::str;
use std::collections::HashMap;
use std::net::{SocketAddr};
use std::ops::DerefMut;
use embedded_svc::{http::Method, io::Write};
use esp_idf_svc::{
    eventloop::EspSystemEventLoop,
    hal::{
        prelude::*,
        gpio::{IOPin, PinDriver, Output, AnyIOPin},
    },
    http::server::{Configuration, EspHttpServer},
    sys::sleep,
};
use log::{warn, info};
use std::sync::{Arc, Mutex};
use std::time::Duration;
use esp_idf_svc::wifi::WifiDeviceId;
use wifi::wifi;
use serde::{Deserialize, Serialize};
use serde_json;
use chrono::Utc;
use esp_syslog;

mod ntp;

#[toml_cfg::toml_config]
#[derive(Debug)]
pub struct Config {
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,

    #[default("127.0.0.1")]
    syslog_host: &'static str,
    #[default("514")]
    syslog_port: &'static str,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct DoseRequest {
    name: String,
    spin_time: u32,
    wait_time: u32,
    pump_time: u32,
}

#[derive(Clone)]
pub struct DoseDevice {
    name: String,
    stir_plate: Option<Arc<Mutex<PinDriver<'static, AnyIOPin, Output>>>>,
    pump: Arc<Mutex<PinDriver<'static, AnyIOPin, Output>>>,
}

fn main() -> Result<()> {
    esp_idf_svc::sys::link_patches();
    esp_idf_svc::log::EspLogger::initialize_default();
    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = CONFIG;


    let peripherals = Peripherals::take().unwrap();
    let sys_loop = EspSystemEventLoop::take()?;

    let mut mac = [0u8; 6];

    // Connect to the Wi-Fi network
    let _wifi = match wifi(
        app_config.wifi_ssid,
        app_config.wifi_psk,
        peripherals.modem,
        sys_loop,
    ) {
        Ok(inner) => {
            info!("Connected to Wi-Fi network!");
            mac = inner.get_mac(WifiDeviceId::Sta).unwrap();
            info!("my mac address is: {:?}", mac);
            inner
        }
        Err(err) => {
            // Red!
            bail!("Could not connect to Wi-Fi network: {:?}", err)
        }
    };
    let mac_hex = mac.iter().map(|b| format!("{:02x}", b)).collect::<String>();
    let hostname = format!("esp32-{}", mac_hex);

    // sync ntp
    ntp::ntp_sync()?;

    let client = std::net::UdpSocket::bind("127.0.0.1:514").unwrap();
    let address = SocketAddr::new(app_config.syslog_host.parse()?, app_config.syslog_port.parse()?);
    client.connect(address)?;
    client.send(b"hello world")?;

    info!("Sent some data to a udp port!");

    esp_syslog::init_udp(
        SocketAddr::new("127.0.0.1".parse()?, 1514),
        address,
        hostname,
        esp_syslog::Facility::LOG_USER,
        log::LevelFilter::Info,
        "main".to_string(),
        0,
    ).unwrap();

    // initialize the groups
    let mut devices: HashMap<String, DoseDevice> = HashMap::new();

    devices.insert("1".to_string(), DoseDevice {
        name: "1".to_string(),
        stir_plate: Some(Arc::new(Mutex::new(PinDriver::output(peripherals.pins.gpio0.downgrade())?.into()))),
        pump: Arc::new(Mutex::new(PinDriver::output(peripherals.pins.gpio1.downgrade())?.into())),
    });

    devices.insert("2".to_string(), DoseDevice {
        name: "2".to_string(),
        stir_plate: Some(Arc::new(Mutex::new(PinDriver::output(peripherals.pins.gpio2.downgrade())?.into()))),
        pump: Arc::new(Mutex::new(PinDriver::output(peripherals.pins.gpio3.downgrade())?.into())),
    });

    devices.insert("3".to_string(), DoseDevice {
        name: "3".to_string(),
        stir_plate: Some(Arc::new(Mutex::new(PinDriver::output(peripherals.pins.gpio4.downgrade())?.into()))),
        pump: Arc::new(Mutex::new(PinDriver::output(peripherals.pins.gpio5.downgrade())?.into())),
    });

    devices.insert("4".to_string(), DoseDevice {
        name: "4".to_string(),
        stir_plate: Some(Arc::new(Mutex::new(PinDriver::output(peripherals.pins.gpio6.downgrade())?.into()))),
        pump: Arc::new(Mutex::new(PinDriver::output(peripherals.pins.gpio7.downgrade())?.into())),
    });

    devices.insert("5".to_string(), DoseDevice {
        name: "5".to_string(),
        stir_plate: Some(Arc::new(Mutex::new(PinDriver::output(peripherals.pins.gpio8.downgrade())?.into()))),
        pump: Arc::new(Mutex::new(PinDriver::output(peripherals.pins.gpio9.downgrade())?.into())),
    });

    devices.insert("flush".to_string(), DoseDevice {
        name: "flush".to_string(),
        stir_plate: None,
        pump: Arc::new(Mutex::new(PinDriver::output(peripherals.pins.gpio10.downgrade())?.into())),
    });

    // Set the HTTP server
    let mut server = EspHttpServer::new(&Configuration::default())?;
    // http://<sta ip>/ handler
    server.fn_handler("/", Method::Get, |request| {
        info!("handling GET /");
        let html = index_html();
        let mut response = request.into_ok_response()?;
        response.write_all(html.as_bytes())?;
        Ok(())
    })?;

    server.fn_handler("/health", Method::Get, move |request| {
        info!("handling GET /health");
        let resp = health();
        let mut response = request.into_response(
            200,
            Option::from("OK"),
            &[("Content-Type", "application/json")]
        )?;
        response.write_all(resp.as_bytes())?;
        Ok(())
    })?;

    server.fn_handler("/dose", Method::Post, move |mut request| {
        info!("handling POST /dose");
        let mut request_buffer: Vec<u8> = vec![];
        let mut buf = [0u8; 128]; // chunks of 128 bytes
        loop {
            let bytes_read = request.read(&mut buf)?;
            if bytes_read == 0 {
                break;
            }
            request_buffer.extend_from_slice(&buf[..bytes_read]);
        }

        //let mut buf = [0u8; 1024];
        //let bytes_read = request.read(&mut buf)?;
        info!("got input body ({} bytes): {:?}", request_buffer.len(), str::from_utf8(&request_buffer.clone()));
        let dose_req: DoseRequest = match serde_json::from_str::<DoseRequest>(str::from_utf8(&request_buffer).unwrap()) {
            Ok(m) => m,
            Err(e) => {
                warn!("Unable to process request: {}", e);
                let mut response = request.into_response(
                    400,
                    Option::from("Bad Request"),
                    &[("Content-Type", "application/json")]
                )?;
                response.write_all("{\"error\": \"bad request\"}".as_bytes())?;
                return Ok(())
            }
        };
        drop(request_buffer);

        match devices.get(&dose_req.name) {
            None => {
                info!("Device not found: {}", dose_req.name);
                let mut response = request.into_response(
                    404,
                    Option::from("Device not found"),
                    &[("Content-Type", "application/json")]
                )?;
                response.write_all("{\"error\": \"device not found\"}".as_bytes())?;
                Ok(())
            }
            Some(device) => {
                info!("Dosing device: {:?}", dose_req);
                let mut response = request.into_response(
                    200,
                    Option::from("OK"),
                    &[("Content-Type", "application/json")]
                )?;
                match device.clone().stir_plate {
                    None => {
                        let mut pump = device.pump.lock()?;
                        pump.deref_mut().set_high()?;
                        std::thread::sleep(Duration::from_millis(dose_req.pump_time as u64));
                        pump.deref_mut().set_low()?;
                        info!("Dosing complete: {:?}", dose_req);
                        response.write_all("{\"status\": \"complete\"}".as_bytes())?;
                        Ok(())
                    }
                    Some(stir_plate) => {
                        let mut spin = stir_plate.lock()?;
                        let mut pump = device.pump.lock()?;
                        spin.deref_mut().set_high()?;
                        std::thread::sleep(Duration::from_millis(dose_req.spin_time as u64));
                        spin.deref_mut().set_low()?;
                        std::thread::sleep(Duration::from_millis(dose_req.wait_time as u64));
                        pump.deref_mut().set_high()?;
                        std::thread::sleep(Duration::from_millis(dose_req.pump_time as u64));
                        pump.deref_mut().set_low()?;
                        info!("Dosing complete: {:?}", dose_req);
                        response.write_all("{\"status\": \"complete\"}".as_bytes())?;
                        Ok(())
                    }
                }
            }
        }
    })?;

    info!("Server awaiting connection");

    // Prevent program from exiting
    let mut i = 0;
    loop {
        unsafe { sleep(1000); }
        i += 1;
        if i % 600 == 0 {
            match ntp::ntp_sync() {
                Ok(_) => info!("NTP sync successful"),
                Err(e) => warn!("NTP sync failed: {}", e),
            }
        }
    }
}

fn templated(content: impl AsRef<str>) -> String {
    format!(
        r#"
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>esp-rs web server</title>
    </head>
    <body>
        {}
    </body>
</html>
"#,
        content.as_ref()
    )
}

fn index_html() -> String {
    let time = Utc::now().timestamp() as u64;
    templated(
        format!("Hello from ReliableReefs AutoFeeder ESP32-C3, version={} timestamp={}", env!("CARGO_PKG_VERSION"), time)
    )
}

fn health() -> String {
    let time = Utc::now().timestamp() as u64;
    format!(
        r#"{{"status": "ok", "version": "{}", "time": "{}"}}"#, env!("CARGO_PKG_VERSION"), time
    )
}
