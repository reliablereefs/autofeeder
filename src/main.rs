#![allow(dead_code)]
use anyhow::{bail, Result};
use core::str;
use std::collections::HashMap;
use std::ops::DerefMut;
use embedded_svc::{http::Method, io::Write};
use esp_idf_svc::{
    eventloop::EspSystemEventLoop,
    hal::{
        prelude::*,
        gpio::{IOPin, PinDriver, Output, AnyIOPin},
    },
    http::server::{Configuration, EspHttpServer},
    sys::sleep,
};
use log::{warn, info};
use std::sync::{Arc, Mutex};
use std::time::Duration;
use esp_idf_svc::wifi::WifiDeviceId;
use wifi::wifi;
use serde::{Deserialize, Serialize};
use serde_json;

#[toml_cfg::toml_config]
#[derive(Debug)]
pub struct Config {
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct DoseRequest {
    name: String,
    spin_time: u32,
    wait_time: u32,
    pump_time: u32,
}

#[derive(Clone)]
pub struct DoseDevice {
    name: String,
    stir_plate: Option<Arc<Mutex<PinDriver<'static, AnyIOPin, Output>>>>,
    pump: Arc<Mutex<PinDriver<'static, AnyIOPin, Output>>>,
}

fn main() -> Result<()> {
    esp_idf_svc::sys::link_patches();
    esp_idf_svc::log::EspLogger::initialize_default();

    let peripherals = Peripherals::take().unwrap();
    let sys_loop = EspSystemEventLoop::take()?;

    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = CONFIG;
    let mut mac = [0u8; 6];

    // Connect to the Wi-Fi network
    let _wifi = match wifi(
        app_config.wifi_ssid,
        app_config.wifi_psk,
        peripherals.modem,
        sys_loop,
    ) {
        Ok(inner) => {
            info!("Connected to Wi-Fi network!");
            mac = inner.get_mac(WifiDeviceId::Sta).unwrap();
            info!("my mac address is: {:?}", mac);
            inner
        }
        Err(err) => {
            // Red!
            bail!("Could not connect to Wi-Fi network: {:?}", err)
        }
    };

    // initialize the groups
    let mut devices: HashMap<String, DoseDevice> = HashMap::new();

    devices.insert("1".to_string(), DoseDevice {
        name: "1".to_string(),
        stir_plate: Some(Arc::new(Mutex::new(PinDriver::output(peripherals.pins.gpio0.downgrade())?.into()))),
        pump: Arc::new(Mutex::new(PinDriver::output(peripherals.pins.gpio1.downgrade())?.into())),
    });

    devices.insert("2".to_string(), DoseDevice {
        name: "2".to_string(),
        stir_plate: Some(Arc::new(Mutex::new(PinDriver::output(peripherals.pins.gpio2.downgrade())?.into()))),
        pump: Arc::new(Mutex::new(PinDriver::output(peripherals.pins.gpio3.downgrade())?.into())),
    });

    devices.insert("3".to_string(), DoseDevice {
        name: "3".to_string(),
        stir_plate: Some(Arc::new(Mutex::new(PinDriver::output(peripherals.pins.gpio4.downgrade())?.into()))),
        pump: Arc::new(Mutex::new(PinDriver::output(peripherals.pins.gpio5.downgrade())?.into())),
    });

    devices.insert("4".to_string(), DoseDevice {
        name: "4".to_string(),
        stir_plate: Some(Arc::new(Mutex::new(PinDriver::output(peripherals.pins.gpio6.downgrade())?.into()))),
        pump: Arc::new(Mutex::new(PinDriver::output(peripherals.pins.gpio7.downgrade())?.into())),
    });

    devices.insert("5".to_string(), DoseDevice {
        name: "5".to_string(),
        stir_plate: Some(Arc::new(Mutex::new(PinDriver::output(peripherals.pins.gpio8.downgrade())?.into()))),
        pump: Arc::new(Mutex::new(PinDriver::output(peripherals.pins.gpio9.downgrade())?.into())),
    });

    devices.insert("flush".to_string(), DoseDevice {
        name: "flush".to_string(),
        stir_plate: None,
        pump: Arc::new(Mutex::new(PinDriver::output(peripherals.pins.gpio10.downgrade())?.into())),
    });

    // Set the HTTP server
    let mut server = EspHttpServer::new(&Configuration::default())?;
    // http://<sta ip>/ handler
    server.fn_handler("/", Method::Get, |request| {
        info!("handling GET /");
        let html = index_html();
        let mut response = request.into_ok_response()?;
        response.write_all(html.as_bytes())?;
        Ok(())
    })?;

    server.fn_handler("/health", Method::Get, move |request| {
        info!("handling GET /health");
        let resp = health();
        let mut response = request.into_response(
            200,
            Option::from("OK"),
            &[("Content-Type", "application/json")]
        )?;
        response.write_all(resp.as_bytes())?;
        Ok(())
    })?;

    server.fn_handler("/dose", Method::Post, move |mut request| {
        info!("handling POST /dose");
        let mut request_buffer: Vec<u8> = vec![];
        let mut buf = [0u8; 512]; // chunks of 512 bytes
        loop {
            let bytes_read = request.read(&mut buf)?;
            if bytes_read == 0 {
                break;
            }
            request_buffer.extend_from_slice(&buf[..bytes_read]);
        }

        //let mut buf = [0u8; 1024];
        //let bytes_read = request.read(&mut buf)?;
        info!("got input body ({} bytes): {:?}", request_buffer.len(), str::from_utf8(&request_buffer.clone()));
        let dose_req: DoseRequest = match serde_json::from_str::<DoseRequest>(str::from_utf8(&request_buffer).unwrap()) {
            Ok(m) => m,
            Err(e) => {
                warn!("Unable to process request: {}", e);
                let mut response = request.into_response(
                    400,
                    Option::from("Bad Request"),
                    &[("Content-Type", "application/json")]
                )?;
                response.write_all("{\"error\": \"bad request\"}".as_bytes())?;
                return Ok(())
            }
        };
        drop(request_buffer);

        match devices.get(&dose_req.name) {
            None => {
                info!("Device not found: {}", dose_req.name);
                let mut response = request.into_response(
                    404,
                    Option::from("Device not found"),
                    &[("Content-Type", "application/json")]
                )?;
                response.write_all("{\"error\": \"device not found\"}".as_bytes())?;
                Ok(())
            }
            Some(device) => {
                info!("Dosing device: {:?}", dose_req);
                let mut response = request.into_response(
                    200,
                    Option::from("OK"),
                    &[("Content-Type", "application/json")]
                )?;
                match device.clone().stir_plate {
                    None => {
                        let mut pump = device.pump.lock()?;
                        pump.deref_mut().set_high()?;
                        std::thread::sleep(Duration::from_millis(dose_req.pump_time as u64));
                        pump.deref_mut().set_low()?;
                        info!("Dosing complete: {:?}", dose_req);
                        response.write_all("{\"status\": \"complete\"}".as_bytes())?;
                        Ok(())
                    }
                    Some(stir_plate) => {
                        let mut spin = stir_plate.lock()?;
                        let mut pump = device.pump.lock()?;
                        spin.deref_mut().set_high()?;
                        std::thread::sleep(Duration::from_millis(dose_req.spin_time as u64));
                        spin.deref_mut().set_low()?;
                        std::thread::sleep(Duration::from_millis(dose_req.wait_time as u64));
                        pump.deref_mut().set_high()?;
                        std::thread::sleep(Duration::from_millis(dose_req.pump_time as u64));
                        pump.deref_mut().set_low()?;
                        info!("Dosing complete: {:?}", dose_req);
                        response.write_all("{\"status\": \"complete\"}".as_bytes())?;
                        Ok(())
                    }
                }
            }
        }
    })?;

    info!("Server awaiting connection");

    // Prevent program from exiting
    loop {
        unsafe { sleep(1000); }
    }
}

fn templated(content: impl AsRef<str>) -> String {
    format!(
        r#"
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>esp-rs web server</title>
    </head>
    <body>
        {}
    </body>
</html>
"#,
        content.as_ref()
    )
}

fn index_html() -> String {
    templated(
        format!("Hello from ReliableReefs AutoFeeder ESP32-C3, version: {}!", env!("CARGO_PKG_VERSION"))
    )
}

fn health() -> String {
    format!(
        r#"{{"status": "ok", "version": "{}"}}"#, env!("CARGO_PKG_VERSION")
    )
}